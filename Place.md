# Place

## 模拟退火算法（simulated annealing，SA）

Altera使用模拟退火算法  
最早的思想由 N. Metropolis 等人于 1953 年提出，1983 年，S. Kirkpatrick 等成功地将退火思想引入到组合优化领域。

该算法的灵感来源于固体物质的退火过程。它是一种基于蒙特卡罗迭代求解策略的随机寻优算法，通过赋予搜索过程一种时变且最终趋于零的概率突跳性，从而可有效避免陷入局部极小并最终趋于全局最优。理论上算法具有概率的全局优化性能，目前已在工程中得到广泛应用，诸如 VLSI、生产调度、控制工程、机器学习、神经网络、信号处理、模式识别、图像处理、离散/连续变量的结构优化问题等，能有效解决许多常规优化方法难以处理的组合优化问题和复杂函数优化问题。

其原理是用固体退火模拟组合优化问题，将内能 E 模拟为目标函数值 F，温度 T 演化成控制参数 T。算法从某一较高初温出发，伴随温度参数的不断下降，结合概率突跳特性在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。

具体步骤如下：
1. 初始化：设定初始温度 T（充分大）、初始解状态 S（算法迭代的起点）以及每个 T 值的迭代次数 L；
2. 对 k = 1 到 L 进行以下操作：
    1. 产生新解 S′；
    2. 计算增量ΔT′ = C(S′) - C(S)，其中 C(S)为评价函数；
    3. 若ΔT′ < 0，则接受 S′作为新的当前解，否则以概率 exp(-ΔT′ / T)接受 S′作为新的当前解；
    4. 如果满足终止条件则输出当前解作为最优解，结束程序。终止条件通常取为连续若干个新解都没有被接受时终止算法；
3. 逐渐减少 T 值（且 T -> 0），然后转至步骤 2。

模拟退火算法新解的产生和接受可分为四个具体步骤：
1. 由一个产生函数从当前解产生一个位于解空间的新解。为便于后续计算和接受，通常选择由当前新解经过简单变换即可产生新解的方法，如对构成新解的全部或部分元素进行置换、互换等，需注意产生新解的变换方法决定了当前新解的邻域结构，会对冷却进度表的选取产生一定影响；
2. 计算与新解对应的目标函数差，由于目标函数差仅由变换部分产生，按增量计算是较快的方法；
3. 判断新解是否被接受，常用的接受准则是 Metropolis 准则：若ΔT′ < 0 则接受 S′作为新的当前解 S，否则以概率 exp(-ΔT′ / T)接受 S′作为新的当前解 S；
4. 当新解被确定接受时，用新解代替当前解，只需将当前解中对应于产生新解时的变换部分予以实现，同时修正目标函数值即可，此时当前解实现了一次迭代，可在此基础上开始下一轮试验；当新解被判定为舍弃时，则在原当前解的基础上继续下一轮试验。

在退火过程中，参数的控制较为重要：
1. 初始温度 T(0)应选得足够高，使所有转移状态都能被接受。初始温度越高，获得高质量解的概率越大，但耗费的时间也越长；
2. 退火速率即温度下降方式，简单的下降方式如指数式下降：T(n) = αT(n-1)，其中α是小于 1 的正数，一般取值在 0.8 到 0.99 之间，需使在每一温度下有足够的转移尝试，但指数式下降的收敛速度较慢；
3. 当温度下降到终止温度或达到用户设定的阈值时，退火完成。

例如，在求解目标函数 f(x) = x1^2 + x2^2 + 8 在约束条件 x1^2 - x2 > 0 和 -x1 - x2^2 + 2 = 0 下的最小值问题时，可使用模拟退火算法。以下是使用 Matlab 实现的示例代码：
```matlab
% 生成初始解，求目标函数 f(x)=x1^2+x2^2+8 在约束条件 x1^2-x2>0 ; -x1-x2^2+2=0 下的最小值问题
sol_new2 = 1;  %（1）解空间（初始解）
sol_new1 = 2 - sol_new2^2;
sol_current1 = sol_new1;
sol_best1 = sol_new1;
sol_current2 = sol_new2;
sol_best2 = sol_new2;
e_current = inf;
e_best = inf;
rand('state', sum(clock));  % 初始化随机数发生器
t = 90;  % 初始温度
tf = 89.9;  % 结束温度
a = 0.99;  % 温度下降比例

while t >= tf  %（7）结束条件
    for r = 1 : 1000  % 退火次数
        % 产生随机扰动（3）新解的产生
        sol_new2 = sol_new2 + rand * 0.2;
        sol_new1 = 2 - sol_new2^2;
        % 检查是否满足约束
        if sol_new1^2 - sol_new2 >= 0 && -sol_new1 - sol_new2^2 + 2 == 0 && sol_new1 >= 0 && sol_new2 >= 0
            else
                sol_new2 = rand * 2;
                sol_new1 = 2 - sol_new2^2;
                continue;
        end
        % 退火过程
        e_new = sol_new1^2 + sol_new2^2 + 8;  %（2）目标函数
        if e_new < e_current  %（5）接受准则
            e_current = e_new;
            sol_current1 = sol_new1;
            sol_current2 = sol_new2;
            if e_new < e_best  % 把冷却过程中最好的解保存下来
                e_best = e_new;
                sol_best1 = sol_new1;
                sol_best2 = sol_new2;
            end
        elseif rand < exp(-(e_new - e_current) / t)  %（4）代价函数差
            e_current = e_new;
            sol_current1 = sol_new1;
            sol_current2 = sol_new2;
        else
            sol_new1 = sol_current1;
            sol_new2 = sol_current2;
        end
        plot(r, e_best, '*')
        hold on
    end
    t = t * a;  %（6）降温
end
disp('最优解为：')
disp(sol_best1)
disp(sol_best2)
disp('目标表达式的最小值等于：')
disp(e_best)
```

Metropolis 准则是模拟退火算法的关键部分，它决定了是否接受一个新的状态。假设前一个状态为 x(n)，系统根据某一指标（如梯度下降、能量等）状态变为 x(n+1)，相应的系统能量由 E(n)变为 E(n+1)，定义系统由 x(n)变为 x(n+1)的接受概率 p 为：如果能量减小了（即ΔE < 0），那么这种转移就被接受（概率为 1）；如果能量增大了（即ΔE > 0），则以概率 exp(-ΔE / (kT))接受这种转移，其中 k 为玻尔兹曼常数，T 为温度。通过这种概率接受的方式，算法有可能跳出局部最优解，从而趋向全局最优解。

接受状态的三条原则如下：
1. 在固定温度下，接受使目标函数下降的候选解的概率要大于使目标函数上升的候选解概率；
2. 随着温度的下降，接受使目标函数上升的解的概率要逐渐减小；
3. 当温度趋于零时，只能接受目标函数下降的解。


## 解析布局算法

Xilinx使用解析布局算法  
**待补充**


## Udev

hqfpga读取对应的device文件(device.udev)，将文件中的内容按照udev模型保存在内存中。   
可以在代码的任何位置调用UDV::UdevBuilder::grabUdev()来获取udev对象。    
可以在代码的任何位置调用print()对其中数据进行输出。

- Tile
    
    表示Grid中的某个位置。

- Spot

    表示某个tile上能够放置什么comp，比如SLICE，PIO，EBR等。一个spot可以放置多种不同comp。


- 注意

    某个device上可以使用的资源有哪些,并不代表在此device上已经放置了这些资源，只是说明可以使用这些数量的资源。   
    遍历全部的spot，获取其中comp对应的type即可。    
    实际上device并没有SLICE等概念。

